anisotropy = FALSE,
time = "month",
control = sdmTMBcontrol(
newton_loops = 1
# nlminb_loops = 2
),
silent = FALSE
)
)
purrr::map(catch_tbl$st_fits, AIC)
purrr::map(catch_tbl$st_fitsB, AIC)
catch_tbl$st_fitsB <- furrr::future_map(
catch_tbl$data,
~ sdmTMB(
catch ~ #0 + year_f
(1 | year_f) +
# mean_depth +
coast_dist_km +
mean_slope +
hours_from_slack
,
offset = "offset",
data = .x,
mesh = sdm_mesh2,
family = sdmTMB::nbinom2(),
spatial = "on",
spatiotemporal = "iid",
anisotropy = FALSE,
time = "month",
control = sdmTMBcontrol(
newton_loops = 1
# nlminb_loops = 2
),
silent = FALSE
)
)
#Predictions incorporating all fixed and random effects
# Generally the impacts of different meshes considered here were negligible
plot_map(catch_preds %>% filter(year == "2019"), exp(est)) +
scale_fill_viridis_c(trans = "sqrt") +
ggtitle("Prediction (fixed effects + all random effects)") +
facet_grid(size_bin~month)
glimpse(set_dat)
set_dat %>% group_by(month) %>% tally()
catch_tbl$st_fits <- furrr::future_map(
catch_tbl$data,
~ sdmTMB(
catch ~ #0 + year_f
(1 | year_f) +
mean_depth +
# coast_dist_km +
# mean_slope +
hours_from_slack
,
offset = "offset",
data = .x,
mesh = sdm_mesh2,
family = sdmTMB::nbinom2(),
spatial = "on",
spatiotemporal = "RW",
anisotropy = FALSE,
time = "month",
control = sdmTMBcontrol(
newton_loops = 1
# nlminb_loops = 2
),
silent = FALSE
)
)
summary(catch_tbl$st_fits[[1]])
sanity(catch_tbl$st_fits[[1]])
catch_tbl$st_fits <- furrr::future_map(
catch_tbl$data,
~ sdmTMB(
catch ~ #0 + year_f
(1 | year_f) +
mean_depth +
# coast_dist_km +
# mean_slope +
hours_from_slack
,
offset = "offset",
data = .x,
mesh = sdm_mesh2,
family = sdmTMB::nbinom2(),
spatial = "on",
spatiotemporal = "iid",
anisotropy = FALSE,
time = "month",
control = sdmTMBcontrol(
newton_loops = 1
# nlminb_loops = 2
),
silent = FALSE
)
)
# import 1.8 X 1.8 km grid generated in prep_bathymetry.R in chinTagging repo
pred_bathy_grid <- readRDS(
here::here("data", "pred_bathy_grid_utm.RDS"))
# generate combinations for month/year
month_year <- expand.grid(
month = c(5, 6, 7, 8, 9),
year_day = c(166, 196, 227, 258),
year = unique(catch$year)
)
pred_grid_list <- vector(mode = "list", length = nrow(month_year))
for (i in seq_along(pred_grid_list)) {
pred_grid_list[[i]] <- pred_bathy_grid %>%
filter(X < max(catch$xUTM + 1000) & X > min(catch$xUTM - 1000),
Y < max(catch$yUTM + 1000) & Y > min(catch$yUTM - 1000)) %>%
mutate(year = month_year$year[i],
month = month_year$month[i],
year_day = month_year$year_day[i])
}
pred_grid <- pred_grid_list %>%
bind_rows() %>%
mutate(
xUTM_ds = X / 1000,
yUTM_ds = Y / 1000,
coast_dist_km = shore_dist / 1000,
hours_from_slack = median(catch$hours_from_slack),
moon_illuminated = 0.5,
year_f = as.factor(year)
) %>%
dplyr::select(
X, Y, xUTM_ds, yUTM_ds, month, year, year_f, year_day, hours_from_slack,
moon_illuminated, mean_depth = depth, mean_slope = slope
)
catch_tbl$preds <- purrr::map(
catch_tbl$st_fits,
~ predict(.x, newdata = pred_grid)
)
catch_preds <- catch_tbl %>%
dplyr::select(size_bin, preds) %>%
unnest(cols = c(preds))
# helper function for simple predictive maps
plot_map <- function(dat, column) {
ggplot() +
geom_raster(data = dat, aes(X, Y, fill = {{ column }})) +
coord_fixed() +
ggsidekick::theme_sleek()
}
#Predictions incorporating all fixed and random effects
# Generally the impacts of different meshes considered here were negligible
plot_map(catch_preds %>% filter(year == "2019"), exp(est)) +
scale_fill_viridis_c(trans = "sqrt") +
ggtitle("Prediction (fixed effects + all random effects)") +
facet_grid(size_bin~month)
plot_map(catch_preds %>% filter(month == "7"), exp(est)) +
scale_fill_viridis_c(trans = "sqrt") +
ggtitle("Prediction (fixed effects + all random effects)") +
facet_grid(size_bin~year) #+
# Spatial random effects (i.e. independent of time)
plot_map(catch_preds, omega_s) +
scale_fill_gradient2() +
ggtitle("Spatial Random Effects") +
facet_wrap(~size_bin) #+
# Spatiotemporal random effects
plot_map(catch_preds, epsilon_st) +
scale_fill_gradient2() +
ggtitle("Spatiotemporal Random Effects") +
facet_grid(size_bin~month)
# Spatiotemporal random effects
eps <- plot_map(catch_preds, epsilon_st) +
scale_fill_gradient2() +
ggtitle("Spatiotemporal Random Effects") +
facet_grid(size_bin~month)
#Predictions incorporating all fixed and random effects
# Generally the impacts of different meshes considered here were negligible
month_preds <- plot_map(catch_preds %>% filter(year == "2019"), exp(est)) +
scale_fill_viridis_c(trans = "sqrt") +
ggtitle("Prediction (fixed effects + all random effects)") +
facet_grid(size_bin~month)
year_preds <- plot_map(catch_preds %>% filter(month == "7"), exp(est)) +
scale_fill_viridis_c(trans = "sqrt") +
ggtitle("Prediction (fixed effects + all random effects)") +
facet_grid(size_bin~year) #+
# Spatial random effects (i.e. independent of time)
omega <- plot_map(catch_preds, omega_s) +
scale_fill_gradient2() +
ggtitle("Spatial Random Effects") +
facet_wrap(~size_bin) #+
# Spatiotemporal random effects
eps <- plot_map(catch_preds, epsilon_st) +
scale_fill_gradient2() +
ggtitle("Spatiotemporal Random Effects") +
facet_grid(size_bin~month)
pdf(here::here("figs", "spatial_preds_sizebins.pdf"))
month_preds
year_preds
omega
eps
dev.off()
glimpse(catch)
catch_stock <- chin %>%
filter(!is.na(agg)) %>%
group_by(event, agg) %>%
summarize(catch = n(), .groups = "drop") %>%
ungroup()
catch_stock
catch_stock <- expand.grid(
event = set_dat$event,
agg = unique(catch_stock$agg)
) %>%
arrange(event) %>%
left_join(., catch_stock, by = c("event", "agg")) %>%
replace_na(., replace = list(catch = 0)) %>%
left_join(., set_dat, by = "event") %>%
mutate(
year_f = as.factor(year),
yUTM_ds = yUTM / 1000,
xUTM_ds = xUTM / 1000,
offset = log(set_dist),
depth_z = scale(mean_depth)[ , 1],
slack_z = scale(hours_from_slack)[ , 1],
week_z = scale(week)[ , 1]
) %>%
# remove sets not on a troller
filter(!grepl("rec", event))
?group_nest
catch_tbl
catch_tbl <- as_tibble(catch) %>%
group_by(size_bin) %>%
group_nest() %>%
rename(group_var = size_bin)
catch_tbl_size <- as_tibble(catch) %>%
group_by(size_bin) %>%
group_nest() %>%
rename(group_var = size_bin)
catch_tbl_stock <- as_tibble(catch_stock) %>%
group_by(agg) %>%
group_nest() %>%
rename(group_var = agg)
catch_tbl_stock
catch_tbl_stock <- as_tibble(catch_stock) %>%
group_by(agg) %>%
group_nest() %>%
rename(group_var = agg) %>%
mutate(grouping = "stock")
catch_tbl_size <- as_tibble(catch) %>%
group_by(size_bin) %>%
group_nest() %>%
rename(group_var = size_bin) %>%
mutate(grouping = "size")
catch_tbl <- rbind(catch_tbl_size, catch_tbl_stock)
# construct a few alternative meshes ( can be applied to all size bins so only
# one needed)
sdm_mesh1 <- make_mesh(catch %>% filter(size_bin == "large"),
c("xUTM_ds", "yUTM_ds"),
n_knots = 250)
sdm_mesh2 <- make_mesh(catch %>% filter(size_bin == "large"),
c("xUTM_ds", "yUTM_ds"),
n_knots = 150)
sub_tbl <- catch_tbl %>% filter(grouping == "stock")
sub_tbl
chin %>%
group_by(agg) %>%
tally()
catch_stock <- chin %>%
filter(!is.na(agg),
fl > 65)
catch_stock %>%
group_by(agg) %>%
tally()
catch_stock <- chin %>%
filter(!is.na(agg),
fl > 65,
# remove rare stocks
!agg %in% c("ECVI")) %>%
group_by(event, agg) %>%
summarize(catch = n(), .groups = "drop") %>%
ungroup()
# clean and bind to set data
set_dat <- readRDS(here::here("data", "cleanSetData.RDS")) %>%
mutate(
week = lubridate::week(date_time_local)
)
catch <- expand.grid(event = set_dat$event,
size_bin = unique(catch_size$size_bin)) %>%
arrange(event) %>%
left_join(., catch_size, by = c("event", "size_bin")) %>%
replace_na(., replace = list(catch = 0)) %>%
left_join(., set_dat, by = "event") %>%
mutate(
year_f = as.factor(year),
yUTM_ds = yUTM / 1000,
xUTM_ds = xUTM / 1000,
offset = log(set_dist),
depth_z = scale(mean_depth)[ , 1],
slack_z = scale(hours_from_slack)[ , 1],
week_z = scale(week)[ , 1]
) %>%
# remove sets not on a troller
filter(!grepl("rec", event))
catch_stock <- expand.grid(
event = set_dat$event,
agg = unique(catch_stock$agg)
) %>%
arrange(event) %>%
left_join(., catch_stock, by = c("event", "agg")) %>%
replace_na(., replace = list(catch = 0)) %>%
left_join(., set_dat, by = "event") %>%
mutate(
year_f = as.factor(year),
yUTM_ds = yUTM / 1000,
xUTM_ds = xUTM / 1000,
offset = log(set_dist),
depth_z = scale(mean_depth)[ , 1],
slack_z = scale(hours_from_slack)[ , 1],
week_z = scale(week)[ , 1]
) %>%
# remove sets not on a troller
filter(!grepl("rec", event))
catch_tbl_size <- as_tibble(catch) %>%
group_by(size_bin) %>%
group_nest() %>%
rename(group_var = size_bin) %>%
mutate(grouping = "size")
catch_tbl_stock <- as_tibble(catch_stock) %>%
group_by(agg) %>%
group_nest() %>%
rename(group_var = agg) %>%
mutate(grouping = "stock")
catch_tbl <- rbind(catch_tbl_size, catch_tbl_stock)
catch_tbl
sub_tbl <- catch_tbl %>% filter(grouping == "stock")
sp_fits <- furrr::future_map(
sub_tbl$data,
~ sdmTMB(
catch ~ (1 | year_f) +
mean_depth +
hours_from_slack
,
offset = "offset",
data = .x,
mesh = sdm_mesh1,
family = sdmTMB::nbinom2(),
spatial = "on",
anisotropy = FALSE,
control = sdmTMBcontrol(
newton_loops = 1
# nlminb_loops = 2
),
silent = FALSE
)
)
catch_stock <- chin %>%
filter(!is.na(agg),
fl > 65,
# remove rare stocks
!agg %in% c("ECVI"))
catch_stock
catch_stock %>%
group_by(agg) %>%
tally()
catch_stock <- chin %>%
filter(!is.na(agg),
fl > 65,
# remove rare stocks
!agg %in% c("ECVI", "WCVI", "WA_OR", "WCVI")) %>%
group_by(event, agg) %>%
summarize(catch = n(), .groups = "drop") %>%
ungroup()
catch_stock <- chin %>%
filter(!is.na(agg),
fl > 65,
# remove rare stocks
!agg %in% c("ECVI", "WCVI", "WA_OR", "Cali")) %>%
group_by(event, agg) %>%
summarize(catch = n(), .groups = "drop") %>%
ungroup()
sub_tbl <- catch_tbl %>% filter(grouping == "stock")
sub_tbl
catch_stock <- expand.grid(
event = set_dat$event,
agg = unique(catch_stock$agg)
) %>%
arrange(event) %>%
left_join(., catch_stock, by = c("event", "agg")) %>%
replace_na(., replace = list(catch = 0)) %>%
left_join(., set_dat, by = "event") %>%
mutate(
year_f = as.factor(year),
yUTM_ds = yUTM / 1000,
xUTM_ds = xUTM / 1000,
offset = log(set_dist),
depth_z = scale(mean_depth)[ , 1],
slack_z = scale(hours_from_slack)[ , 1],
week_z = scale(week)[ , 1]
) %>%
# remove sets not on a troller
filter(!grepl("rec", event))
catch_tbl_size <- as_tibble(catch) %>%
group_by(size_bin) %>%
group_nest() %>%
rename(group_var = size_bin) %>%
mutate(grouping = "size")
catch_tbl_stock <- as_tibble(catch_stock) %>%
group_by(agg) %>%
group_nest() %>%
rename(group_var = agg) %>%
mutate(grouping = "stock")
catch_tbl <- rbind(catch_tbl_size, catch_tbl_stock)
sub_tbl <- catch_tbl %>% filter(grouping == "stock")
sub_tbl
sp_fits <- furrr::future_map(
sub_tbl$data,
~ sdmTMB(
catch ~ (1 | year_f) +
mean_depth +
hours_from_slack
,
offset = "offset",
data = .x,
mesh = sdm_mesh1,
family = sdmTMB::nbinom2(),
spatial = "on",
anisotropy = FALSE,
control = sdmTMBcontrol(
newton_loops = 1
# nlminb_loops = 2
),
silent = FALSE
)
)
purrr::map(catch_tbl$sp_fits, sanity)
purrr::map(sp_fits, sanity)
# residual plots
purrr::map(
sp_fits,
~ {
sims <- simulate(.x, nsim = 30)
dharma_residuals(sims, .x)
}
)
catch_tbl
catch_tbl$st_fits[4:6] <- furrr::future_map(
catch_tbl$data[4:6],
~ sdmTMB(
catch ~ #0 + year_f
(1 | year_f) +
mean_depth +
hours_from_slack
,
offset = "offset",
data = .x,
mesh = sdm_mesh2,
family = sdmTMB::nbinom2(),
spatial = "on",
spatiotemporal = "iid",
anisotropy = FALSE,
time = "month",
control = sdmTMBcontrol(
newton_loops = 1
# nlminb_loops = 2
),
silent = FALSE
)
)
catch_tbl
purrr::map(catch_tbl$st_fits[4:6], sanity)
summary(catch_tbl$st_fits[[6]])
catch_tbl$st_fits[4:6] <- furrr::future_map(
catch_tbl$data[4:6],
~ sdmTMB(
catch ~ #0 + year_f
(1 | year_f) +
mean_depth #+
# hours_from_slack
,
offset = "offset",
data = .x,
mesh = sdm_mesh2,
family = sdmTMB::nbinom2(),
spatial = "on",
spatiotemporal = "iid",
anisotropy = FALSE,
time = "month",
control = sdmTMBcontrol(
newton_loops = 1
# nlminb_loops = 2
),
silent = FALSE
)
)
summary(catch_tbl$st_fits[[6]])
purrr::map(catch_tbl$st_fits[4:6], sanity)
catch_tbl$st_fits[4:6] <- furrr::future_map(
catch_tbl$data[4:6],
~ sdmTMB(
catch ~ #0 + year_f
(1 | year_f)# +
# mean_depth #+
# hours_from_slack
,
offset = "offset",
data = .x,
mesh = sdm_mesh2,
family = sdmTMB::nbinom2(),
spatial = "on",
spatiotemporal = "iid",
anisotropy = FALSE,
time = "month",
control = sdmTMBcontrol(
newton_loops = 1
# nlminb_loops = 2
),
silent = FALSE
)
)
purrr::map(catch_tbl$st_fits[4:6], sanity)
catch_tbl
